<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Technology &#8211; Andy Pande</title>
	<atom:link href="https://github.com/andypande/portfolio/category/technology/feed/" rel="self" type="application/rss+xml" />
	<link>https://github.com/andypande/portfolio/</link>
	<description>Web Development Enthusiast</description>
	<lastBuildDate>Thu, 21 Jun 2018 04:55:18 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.9.2</generator>
	<item>
		<title>Getting Shit Done for professional procrastinators</title>
		<link>https://github.com/andypande/portfolio/2018/06/21/getting-shit-done-for-professional-procrastinators/</link>
					<comments>https://github.com/andypande/portfolio/2018/06/21/getting-shit-done-for-professional-procrastinators/#respond</comments>
		
		<dc:creator><![CDATA[Pande Saab]]></dc:creator>
		<pubDate>Thu, 21 Jun 2018 04:55:18 +0000</pubDate>
				<category><![CDATA[Productivity]]></category>
		<category><![CDATA[Technology]]></category>
		<category><![CDATA[development]]></category>
		<category><![CDATA[getshitdone]]></category>
		<category><![CDATA[gettingshitdone]]></category>
		<category><![CDATA[lifehack]]></category>
		<category><![CDATA[pomodori]]></category>
		<category><![CDATA[pomodoritechnique]]></category>
		<category><![CDATA[productivityhack]]></category>
		<category><![CDATA[workmanagement]]></category>
		<guid isPermaLink="false">https://andypandedotcom.wordpress.com/?p=80</guid>

					<description><![CDATA[Have you ever felt the feeling of leaving work with an uneasy feeling in your stomach that you are surely...]]></description>
										<content:encoded><![CDATA[<p>Have you ever felt the feeling of leaving work with an uneasy feeling in your stomach that you are surely forgetting something on your to-do list but your brain is too fried and distracted to remember it? So have I, very frequently, up till recently when I came across a foolproof way to get all your tasks done at work AND keep your mind organized and sane.</p>
<p>The productivity hack is called The Pomodoro Technique.</p>
<p>If you are not familiar with the technique, the jist of it is as follows:</p>
<ul>
<li>Work in 25 minute increments</li>
<li>5 minutes of break time after 25 minute work</li>
<li>DO NOT end a pomodori early – if you finish the task with time to spare, review your notes or see if you can enhance the task in any way possible</li>
<li>DO NOT check email during a pomodori – only focused work during this time. How hard is it to work for 25 minutes anyways – a break is coming right after</li>
<li>Mandatory that you take a 5 minute break after each pomodori and a 15 minute break after a set of 4 pomodori &#8211; feel free to check email during this break</li>
<li>If any idea comes up to distract pomodori, simply jot it down and get back to task at hand</li>
<li>Review idea post pomodori completion and add it to To-Do list if still important</li>
<li>If something can be completed under 2 mins, just do it now. Otherwise write it down</li>
<li>If anyone comes by to discuss during Pomodoro, just tell them you’ll get back with them in time after this Pomodoro ends &#8211; no one will get upset by having to wait less than a half hour. This one is really important &#8211; Do not be afraid to say you will get back to them shortly.</li>
</ul>
<p>The way I setup my pomodori list is on a note on my desktop. At the top of the note, I have the rules you see above and below the rules I keep a list of my tasks. Each day starts with looking over these tasks and ensuring the right tasks are on the list for the day and estimating how many 25 minute work increments it will take to complete each task. Each day will be different based on meetings and obligations so I would recommend slicing up the rest of the leftover hours of the day into 25 minute increments and that is how many Pomodori&#8217;s you have to work with. A screenshot of my desktop monitor looks like this: <img loading="lazy" class="alignnone size-full wp-image-81" src="https://github.com/andypande/portfolio/wp-content/uploads/2018/06/image.png" alt="image" width="1600" height="900" /></p>
<p>Anyone can concentrate for 25 minutes at a time, and more often than not, before hitting that 25 minute mark, you will be in a flow state on your current task and can take the 5 minute break to catch up on emails before getting excited for the 25 minute buzzer to sound again so you can get back into the flow.</p>
<p>Since implementing this technique into my daily workday, I have seen my productivity skyrocket and I no longer feel overwhelmed or anxious on a daily basis as was the norm previously. I have also noticed caffeine consumption drop considerably on a daily basis but focus is greatly increased.</p>
<p>Bonus: Chrome has a fantastic plugin for tracking your pomodoro cycles and I highly recommend you use it: https://chrome.google.com/webstore/detail/marinara-pomodoro%C2%AE-assist/lojgmehidjdhhbmpjfamhpkpodfcodef?utm_source=gmail</p>
<p>&nbsp;</p>
]]></content:encoded>
					
					<wfw:commentRss>https://github.com/andypande/portfolio/2018/06/21/getting-shit-done-for-professional-procrastinators/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>5 Day Journey to Improve Performance of your AngularJS application</title>
		<link>https://github.com/andypande/portfolio/2018/05/13/5-day-journey-to-improve-performance-of-your-angularjs-application/</link>
					<comments>https://github.com/andypande/portfolio/2018/05/13/5-day-journey-to-improve-performance-of-your-angularjs-application/#respond</comments>
		
		<dc:creator><![CDATA[Pande Saab]]></dc:creator>
		<pubDate>Sun, 13 May 2018 00:44:34 +0000</pubDate>
				<category><![CDATA[Technology]]></category>
		<guid isPermaLink="false">https://andypandedotcom.wordpress.com/?p=49</guid>

					<description><![CDATA[Recently I came across a project where I had to take on the job of reducing the total watcher count...]]></description>
										<content:encoded><![CDATA[<p class="graf graf--p">Recently I came across a project where I had to take on the job of reducing the total watcher count on a website where the total data set visible to the user was potentially infinite. As a bonus, this website had to be responsive and usable on any and all devices of all shapes and sizes — this post documents my 5 day journey to reduce the watcher count of an AngularJS 1.4 application to a managable state. Hopefully you are not in the same predicatment as me and are using Angular or React by this point &#8211; c&#8217;mon it&#8217;s 2018 &#8211; what are you waiting for?! But if you are not, I sympathize with you and encourage you to read on.</p>
<p class="graf graf--p"><strong class="markup--strong markup--p-strong">Day 1:</strong></p>
<p class="graf graf--p">First and foremost, before embarking on the journey to reduce the overall watcher count — I had to arm myself with the right tools. After a bit of frantic googling — I came across the following two plugins that would help me get a grasp on how bloated the applications UI was with watchers and help to pinpoint which elements were the biggest offenders. I’d highly recommend installing these two Chrome plugins:</p>
<ol class="postList">
<li class="graf graf--li">Angular Total Watchers —  <a class="markup--anchor markup--li-anchor" href="https://chrome.google.com/webstore/detail/angular-watchers/nlmjblobloedpmkmmckeehnbfalnjnjk?hl=en-US" target="_blank" rel="noopener noreferrer">Total Watcher Count Plugin</a></li>
<li class="graf graf--li">AngularJs Batarang- <a class="markup--anchor markup--li-anchor" href="https://chrome.google.com/webstore/detail/angularjs-batarang/ighdmehidhipcmcojjgiloacoafjmpfk?hl=en-US" target="_blank" rel="nofollow noopener noreferrer">Detailed Watcher Breakdown Plugin</a></li>
</ol>
<p class="graf graf--p"><strong class="markup--strong markup--p-strong">Day 2:</strong></p>
<p class="graf graf--p">Armed with the toolset to get control of the watcher count, the next assignment was to blindly open as many tabs as possible for anything related to AngularJs watcher count reduction and start to compile knowledge. All a half day of research, I can safely say that I have compiled the best articles to help you understand Angular Watchers in the simplest terms possible.</p>
<ol class="postList">
<li class="graf graf--li">Perhaps the most valuable use of time to help you get your watcher count down will be to first understand how the Ins and Outs of AngularJS really work — especially the digest cycle — which is where all the watchers are evaluated. The brilliant Minko Gevchev has setup a skinny version of AngularJS on his github respository and written an invaluable post on understanding  <a href="http://blog.mgechev.com/2015/03/09/build-learn-your-own-light-lightweight-angularjs/" target="_blank" rel="noopener noreferrer">bare bones of AngularJs</a> . I would highly recommend checking out his GitHub repo for the lightweight AngularJS as well and set breakpoints to debug through the digest cycle to understand what happens <a href="https://github.com/mgechev/light-angularjs" target="_blank" rel="noopener noreferrer">under the hood of AngularJS</a>. This will not only help you with reducing the watcher count on your page but also set you up for writing high performance code in your future AngularJS projects.</li>
<li class="graf graf--li">Here are a few more valuable resources on <a class="markup--anchor markup--li-anchor" href="http://techiejs.com/Blog/Post/Understanding-The-AngularJS-Digest-Loop" target="_blank" rel="nofollow noopener noreferrer">understanding Dirty Checking</a> and the <a class="markup--anchor markup--li-anchor" href="https://www.ng-book.com/p/The-Digest-Loop-and-apply/" target="_blank" rel="nofollow noopener noreferrer">digest cycle of AngularJS</a>.</li>
</ol>
<p class="graf graf--p">I understand that we are on day 2 of the Journey already and no code has been modified to reduce the watcher count but I would highly recommend not skipping ahead and understanding why a higher watcher count slows down an AngularJs application before getting your hands dirty with coding.</p>
<p class="graf graf--p"><strong class="markup--strong markup--p-strong">Day 3:</strong></p>
<p class="graf graf--p">One-Time binding to the rescue! Perhaps the most valuable resource you will come across for reducing total AngularJS watchers is one-time binding. The basic theory behind one time binding is that for elements on your page that only need to be rendered once and will not be changed based on user interaction should use one-time binding. I would recommend using the following steps for applying one-time binding:</p>
<ol>
<li>Take stock of what your total watcher count is using the <a href="https://chrome.google.com/webstore/detail/angular-watchers/nlmjblobloedpmkmmckeehnbfalnjnjk?hl=en-US">Angular Total Watchers Plugin</a> recommended above &#8211; you did download the plugin right?</li>
<li>Don&#8217;t be discouraged if the watcher count is incredibly high. We will reduce it to a manageable number before the end of this article</li>
<li>Open up your html code and do a global find for the text &#8220;{{&#8221; and replace it with &#8220;{{::&#8221;. Refresh your page and observe total watcher count drop dramatically for your page like magic.</li>
<li>Repeat step 3 but do a global search for &#8216; ng-if=&#8221; &#8216; and replace with &#8216; ng-if=&#8221;:: &#8216;. Also follow this syntax for ng-show, ng-disabled, and basically any other ng-* directives.</li>
<li>Your watcher count should be incredibly low at this point and your app&#8217;s look and feel should be exactly the same upon page load. But, unfortunately &#8211; all user interaction on the page will not function anymore.</li>
<li>Go through all the places in your html code where you applied one time binding and determine whether the values of these directives will change based on user interaction with the page. If they only need to be displayed once to the user and will never change until page refresh, leave the one-time binding and move on. For the data elements that could change based on user interaction or new data &#8211; remove the one-time binding syntax :: off the html elements.</li>
<li>Refresh your page after you have gone through this exercise and observe that your watcher count should be in a lot more managable state now.</li>
</ol>
<p><span style="text-decoration:underline;"><strong>NOTE: </strong></span> One-time binding was only added to the AngularJS core in version 1.3. If you are using an earlier version than 1.3, please navigate over to the <a href="https://github.com/Pasvaz/bindonce">Bind-Once</a> plugin and implement in your code which will give you the same functionality as the 1.3 and beyond :: syntax.</p>
<p><strong>Day 4</strong>:</p>
<p>The next code optimization will discuss improving performance on the ng-repeat directives in your application. Look &#8211; if you have used AngularJS &#8211; you gotta love ng-repeat. It&#8217;s simple implementation and vast power is one of the best features of AngularJS. But, it certainly comes with it&#8217;s drawbacks when the total elements in the array it is being applied to starts to grow. Consider the code block below:</p>
<p>&lt;ul ng-repeat=&#8221;beer in beers&#8221;&gt; &lt;li&gt;{{beer.name}}&lt;/li&gt; &lt;/ul&gt;</p>
<p>If you have applied one-time binding to your element within the ng-repeat {{::beer}} and don&#8217;t have to worry about the elements in beers array changing, you are in great shape already. BUT, if you have a dynamic list of beers based on user interaction or filtering, you will notice your page will re-render extremely slowly based on user interaction. Assuming that you have a dynamic list that can be filtered or refreshed based on new data being retrieved from the server, you are likely to have code along the lines of $scope.beers = newBeersFromServer based on a user click. Even if the list of beers retrieved from the server has ONLY one more beer in the array, angular logic will go through and erase all the DOM elements on your UI and repaint them &#8211; an extremely expensive operation. How to improve this you ask? By using another awesome feature you have likely heard of called trackBy. (Note: trackBy was added to Angular core in 1.1.4 so the implementation below will not work for you if you are using an older version of AngularJS). A high level explanation for trackBy goes as follows: AngularJS appends a unique $$hashKey property to every element in your array so that ng-repeat can ensure that it is not rendering any element twice. Every-time your list is refreshed, ng-repeat will &#8211; unfortunately &#8211; go through your whole list and assign a new $$hashKey to every element in the list and repaint the entire DOM again. Instead of using the native $$hashKey to allow ng-repeat to keep track of your elements, AngularJS allows you to specify a unique property in each element in your array for AngularJS to use for rendering and tracking for changes and updates. Using this knowledge, we can update the code above to state:</p>
<p>&lt;ul ng-repeat=&#8221;beer in beers track by beer.id&#8221;&gt; &lt;li&gt;{{beer.name}}&lt;/li&gt; &lt;/ul&gt;</p>
<p>Here, we are assuming every beer in your list has a different ID and that ID for each beer stays the same in your database throughout it&#8217;s life. Now, whenever Angular re-renders your UI, it does need to dynamically repaint the DOM for every single beer in your list as it sees that prior to refresh and after refresh, the ID for most of the beers in your list are the same. AngularJs knows to only add the DOM elements for new beers which it was previously not tracking in the beers list &#8211; aka the new beers that were fetched from the server. Check out <a href="http://jsfiddle.net/SeKk7/" target="_blank" rel="noopener noreferrer">this fiddle</a> to get a better understanding of the power of trackBy. By default, the code is not using trackBy to render the list of elements and is painfully slow. Once you enable trackBy &#8211; the refresh will be lightning fast as Angular will have no need to repaint the DOM. It really is THAT SIMPLE to improve a noticeable improvement in the re-rendering of your list inside the ng-repeat. Simple rule to follow: If you are using ng-repeat, you should use trackBy.</p>
<p><strong>Day 5:</strong></p>
<p>Today, we will discuss ng-if and the power it has to improve your application rendering dramatically. First, a quick primer on ng-if versus ng-show. Using ng-if is (almost always) recommended over ng-show. The reason is as follows: ng-if actually dynamically adds and removes DOM elements from your DOM whereas ng-show will just change the visibility from display: none to display: block. You can already imagine how using ng-if will greatly reduce the total number of watchers in your application, especially if you have multiple ng-ifs inside a ng-repeat. ng-if is easy enough to understand, but please follow the <a href="https://docs.angularjs.org/api/ng/directive/ngIf" target="_blank" rel="noopener noreferrer">AngularJS core docs</a> to get a better understanding of the directive. To watch the watcher count in your application drop considerably if you have a lot of ng-show directives, do a find all on &#8220;ng-show&#8221; and replace with &#8220;ng-if&#8221; and notice the total watcher count of your application drop using the watcher count plugin. Although implementing ng-if will already considerably improve your performance, another enhanced implementation of ng-if is using ng-if-start and ng-if-end(2 directives that were added to AngularJs as of version 1.2). Consider the code example below:</p>
<div>
<p> {{beer.name}}</p>
</div>
<div>
<p>{{beer.strength}}</p>
</div>
<div>
<p>{{beer.countryOfOrigin}}</p>
</div>
<div>
<p>{{beer.totalHops}}</p>
</div>
<ul>
<li>Instead of having to use multiple ng-ifs in your code, you could change the structure of your code to the following:</li>
</ul>
<div>
<p> {{beer.name}}</p>
</div>
<div>
<p>{{beer.totalHops}}</p>
</div>
<div>
<p>{{beer.countryOfOrigin}}</p>
</div>
<div>
<p>{{beer.strength}}</p>
</div>
<p>&nbsp;</p>
<p>Above, you can notice &#8211; that you have the same ng-if statement applied to multiple elements in your DOM &#8211; angular will add a watcher to every single ng-if element. This would lead to the application having 3 watchers in the first code example above for each ng-if=&#8221;beer.ipa&#8221;. BUT, since you have multiple ng-ifs with the same check, you can restructure your code to use ng-if-start and ng-if-end to reduce your watcher count to 2, 1 for each of the ng-if-start and ng-if-end. While this doesn&#8217;t seem like a noticeable difference of watcher count reduction, any watcher count reduction within a ng-repeat can prove to be extremely valuable as the list of elements in your ng-repeat grows.</p>
<p><strong>Summing Up:</strong></p>
<p>Alas, we have come to the end of our journey and 5 day work week of improving the performance of our AngularJS application. The final step of the journey is to once again open up the AngularJS watcher count plugin and go through each of the pages on your application to observe total watcher count. As recommended by the AngularJS core team, each page in your application should have under 2000 watchers. Once we get above 2000 watchers, you will notice a considerable performance drop in your UI and your page will start crawling, especially on old phones and laptops. If your watcher count is already under 2k for each of the pages in your application, you are likely in good shape and can be confident in knowing your application is well optimized- but if you wish to optimize your application further I would recommend the resources below for improving your application performance even further. As you can see, a few simple changes can make a huge difference in performance when it comes to AngularJS. I hope the above tips help you in developing a responsive and speedy application.</p>
<p><a href="https://www.alexkras.com/11-tips-to-improve-angularjs-performance/" target="_blank" rel="noopener noreferrer">11 tips to Improve AngularJS performance</a></p>
<p><a href="https://www.binpress.com/tutorial/speeding-up-angular-js-with-simple-optimizations/135" target="_blank" rel="noopener noreferrer">Speed up AngularJS Performance with simple optimizations</a></p>
]]></content:encoded>
					
					<wfw:commentRss>https://github.com/andypande/portfolio/2018/05/13/5-day-journey-to-improve-performance-of-your-angularjs-application/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>The &#8216;this&#8217; keyword in Javascript</title>
		<link>https://github.com/andypande/portfolio/2017/11/12/the-this-keyword-in-javascript/</link>
					<comments>https://github.com/andypande/portfolio/2017/11/12/the-this-keyword-in-javascript/#respond</comments>
		
		<dc:creator><![CDATA[Pande Saab]]></dc:creator>
		<pubDate>Sun, 12 Nov 2017 06:43:33 +0000</pubDate>
				<category><![CDATA[Technology]]></category>
		<guid isPermaLink="false">https://andypandedotcom.wordpress.com/?p=12</guid>

					<description><![CDATA[This keyword in javascript explained based on the javascript launchpad lecture course from Simple Programmer. ]]></description>
										<content:encoded><![CDATA[<p>Before reading this post, just remember that the &#8216;this&#8217; keyword is a very confusing topic to understand in javascript and many believe that the way it is programmed in javascript is actually wrong and contains a bug. Do not get discouraged and confused when reading this lecture &#8211; and if you do just come back and re-read it a few more times till it starts to make sense. Also, having a browser with Chrome Developer Tools open really helps solidify the concepts in this lesson about this. Anyways, on to the lesson.</p>
<p>Two quick links that are very important to mention:</p>
<ol>
<li>Incredible detailed video about this lesson can be found at: https://drive.google.com/file/d/11mu-BBkou7BV__Sf5chJaj2rAwHW8AzL/view?usp=sharing</li>
<li>The method used to explain the concepts in this post is based on the Feynman technique &#8211; the best way to learn anything fast: https://www.farnamstreetblog.com/2012/04/learn-anything-faster-with-the-feynman-technique/</li>
</ol>
<p>Step 1: Write out what I know about the subject using simple language and common jargon:</p>
<p>Before we start talking about the keyword &#8216;this&#8217;, we need to understand how the javascript engine interprets Javascript code. Whenever code is run in javascript, it&#8217;s run inside an execution context &#8211;  which is basically a wrapper that wraps up the currently executing code. Whenever JS engine first starts to interpret code, it creates a global execution context with a global object, a special variable called &#8216;this&#8217;, and a link to the outer environment(more to come on that later). On the global execution context, the &#8216;this&#8217; variable is set to Window object because we are running javascript in the browser. The global object is set to Window too whenever we are running javascript in a browser.  Now whenever any code is written in our JS file, it is attached to the global object. Example: If our JS file just has one line of code that says  var a = &#8220;Hello&#8221;, the variable a will be a property on the global window object and you can go into chrome developer tools and type window.a and see that the value &#8220;hello&#8221; is output. Whenever the JS engine is creating the execution context to interpret our code, it does so in two phases. The Creation Phase and the Execution Phase. In the first phase of code rendering, the JS engine sets up the global object, &#8216;this&#8217; and makes sure they have places in memory. Also in this phase, the javascript parser runs through your code and sets up memory space for variables and functions. This step of actually setting up memory space for variables and functions is called &#8216;hoisting&#8217;. In phase one, your code is not actually executed but memory space is assigned for your variables and functions so that they exist in memory. Functions and variables behave a bit differently when they are given memory space. Functions are completely put into memory, including the code inside the function. Variables are just given a memory space and set to undefined &#8211; which is a value that acts as a placeholder until the execution phase of creating the execution context occurs. In phase 2, your code is actually executed using the things setup in the creation phase like the global object, &#8216;this&#8217;, and outer environment reference. The code you have written is run line by line, converting it, compiling it, and finally presenting it as something the computer can understand. Since there is already space in memory for your variables and functions, the code is run line by line in this phase and if it comes across a variable, either the code will use &#8216;undefined&#8217; for the variable if it has not been actually set in our code, or it will use the value the variable is set to. All of this is just a big primer to understand the execution context and how it is created in two phases so that you can get a better understanding of the &#8216;this&#8217; keyword coming up.</p>
<p>Whenever a function is run in your code during the execution phase of the execution context setup, a new execution context is created for every function. This execution context created for the function brings with it the usual characteristics of an execution context &#8211; a variable environment where all the variables created inside that function live, a reference to an outer lexical environment so the execution context knows where to look down the scope chain if it can&#8217;t find a variable in it&#8217;s current execution context, AND of course the keyword &#8216;this&#8217;. &#8216;this&#8217; keyword can point to different things depending on HOW the function that a new execution context is created for is invoked. Whenever you create a function in your by typing either function &#8216;anyName'() or by doing var a = function() -&gt; the &#8216;this&#8217; keyword will point to the global window object inside either of those functions execution contexts. Now, if you create a method inside an object literal instead of just a property, the &#8216;this&#8217; keyword will be set differently. For reference, whenever a primitive value is assigned to an object, it is called an object property. But whenever a function is assigned to an object, it is called an object method. For example, var c = { name: &#8216;the C object&#8217;, log: function(){ console.log(this) }; } Whenever a user calls c.log() in the code, the following steps occur. A new execution context is created for the anonymous function log whenever c.log() is invoked. The &#8216;this&#8217; property for this execution context is set to the variable c instead of the outer window global object. Only when a function is a method within an object is the &#8216;this&#8217; keyword set to the object the function method is sitting inside of. Again, the this keyword is just pointing to a reference of the object and doesn&#8217;t actually make a new copy of the object. As a method of the object that contains you, a method of an object can mutate the surrounding object using the &#8216;this&#8217; keyword. Only and ONLY whenever a function is a method on an object is the &#8216;this&#8217; keyword set to the the object that the method sits in. Otherwise, &#8216;this&#8217; will always point to the global window object. EVEN IF a method on an object has another function created inside it, the execution context created for the function inside the method will have the &#8216;this&#8217; keyword set to the global window object. A lot of people consider this a bug in javascript and that is why a lot of code will have var self = this; as the first line of code to ensure that if you are writing functions within an object method that are relying on properties from the object in the functions, they will point to the object reference that is stored in the &#8216;self&#8217; variable rather than the &#8216;this&#8217; keyword that changes constantly every-time a new execution context is setup. There is only 2 values &#8216;this&#8217; can hold:</p>
<ol>
<li>Reference to the global object &#8211; happens whenever a function is created as a normal function expression or a function is assigned to a variable. In this scenario, whenever the execution context is created for the function when it is run, &#8216;this&#8217; points to just the global object</li>
<li>Reference to the object in which the method was created &#8211; if we create a method in an object (a function within object) &#8211; the &#8216;this&#8217; keyword points to the object that holds that method. BUT, if we create another function within this method and invoke that function, whenever the execution context for the function inside the method is created, the &#8216;this&#8217; keyword points to the global variable window again. Which is why we must use self=this in the beginning of a method rather than rely on the &#8216;this&#8217; keyword in our method declaration to always point to the object where the method is defined.</li>
</ol>
<p>&nbsp;</p>
<p>This post was first created on 11/11/17 &#8211; it is still too wordy and needs to be cleaned up and made easier to understand soon.</p>
]]></content:encoded>
					
					<wfw:commentRss>https://github.com/andypande/portfolio/2017/11/12/the-this-keyword-in-javascript/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
